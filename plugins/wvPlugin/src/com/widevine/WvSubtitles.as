package com.widevine{	import flash.events.*;	import flash.net.*;	import flash.utils.*;			public class WvSubtitles{		private const TIMER_UPDATE_DELAY = 10;		private const RETRY_MAX = 5;				private var subTitleTimer:Timer;				private var urlLoader:URLLoader;		private var textItems:Array;		private var netStream:WvNetStream;				private var callback:Function;				private var eventCallback:Function;				private var _currentStartTime:Number;		private var _currentEndTime:Number;				private var _currentIndex:Number;				private var _retryCount:Number = 0;				private var _ttlFileUrl:String;				private var _offset:Number;				public function WvSubtitles(ns:WvNetStream):void{			netStream = ns;			subTitleTimer = null;		}				public function initialize(ttlFileUrl:String, cb:Function ):Boolean{			showEvent("initialize: " + ttlFileUrl);						_ttlFileUrl = ttlFileUrl;						_retryCount = 0;						callback = cb;						_offset = 0;						return loadXml();		}				public function setOffset(offset:Number):void{			_offset = offset;		}				public function getOffset():Number{			return _offset * 1000;		}				private function loadXml():Boolean{			urlLoader = new URLLoader();			var urlRequest:URLRequest = new URLRequest(_ttlFileUrl);						urlLoader.addEventListener(Event.COMPLETE, loadTextItems, false, 0, true);			urlLoader.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler, false, 0, true);			urlLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler, false, 0, true);			try {				urlLoader.load(urlRequest);			}catch (errObject:Error) {				return false;			}						return true;		}				private function securityErrorHandler(e:SecurityErrorEvent):void {			showEvent("** SecurityErrorEvent: " + e.toString());			if(_retryCount < RETRY_MAX){				_retryCount++;				loadXml();			}		}			private function ioErrorHandler(event:IOErrorEvent):void {			showEvent("** IOErrorEvent: " + event.toString());		}				private function loadTextItems(e:Event):void{			showEvent("loadTextItems");						_currentStartTime = 0;			_currentEndTime = 0;			_currentIndex = 0;						textItems = new Array();						var myPattern:RegExp = /<br \/>/g;						var xml:XML = new XML(urlLoader.data.replace(myPattern, "\n"));						var d:XMLList = xml.descendants("*");			for (var i:Number = 0; i< d.length(); i++) {				if(d[i].localName() == "p"){					var p:XML = d[i];					var begin:String = p.@begin;					var end:String = p.@end;					var duration:String = p.@dur;					var subTitle:String = p.text();									//showEvent(subTitle);										var beginTimeMillis:Number = generateBeginTime(begin) + getOffset();					var durationMillis:Number = generateDuration(beginTimeMillis, end, duration);				   					var textItem:WvTextItem = new WvTextItem(beginTimeMillis, durationMillis, subTitle);					textItems.push(textItem);				}			}															stopTimer();			startTimer();					}				private function generateBeginTime(begin:String):Number{			return generateTime(begin);		}				private function generateDuration(beginTime:Number, end:String, duration:String):Number{						if (duration != null && duration != ""){				var myPattern:RegExp = /s/g;				var dur:Number = new Number(duration.replace(myPattern, ""));				return dur * 1000;			}						if(end != null && end != ""){				var endTime:Number = generateTime(end) + getOffset();				return endTime - beginTime;			}						return 0;		}				private function generateTime(timeStr:String):Number{						var timeParts:Array = timeStr.split(":");						var hours:Number = new Number(timeParts[0]);						var minutes:Number = new Number(timeParts[1]);						var seconds:Number = new Number(timeParts[2].split(".")[0]);						var milliSeconds:Number = new Number(timeParts[2].split(".")[1]);						return milliSeconds + (seconds * 1000) + (minutes * 1000 * 60) + (hours * 1000 * 60 * 60);					}				private function stopTimer(){			showEvent("Stop Timer");			if (subTitleTimer != null && subTitleTimer.running){				subTitleTimer.stop();			}		}				private function startTimer(){			showEvent("Start Timer");			if (subTitleTimer == null || !subTitleTimer.running){				showEvent("new Timer");				subTitleTimer = new Timer(TIMER_UPDATE_DELAY);				subTitleTimer.addEventListener(TimerEvent.TIMER, updateSubTitles, false, 0, true);				subTitleTimer.start();			}		}				private function updateSubTitles(e:TimerEvent){									if (netStream != null && netStream.time > 0){								// Set the subtitle to nothing if trick play is enabled				if(netStream.getPlayScale() != 1){					callback("");					return;				}								var currentMediaTime:Number = netStream.time * 1000;				var subTitleSet:Boolean = false;						if(_currentStartTime <= currentMediaTime && currentMediaTime <= _currentEndTime){					subTitleSet = true;				}else{					if(currentMediaTime < _currentStartTime){						_currentIndex = 0;					}									for ( var i = _currentIndex; i < textItems.length; i++){						var subTitle:String = textItems[i].checkForSubTitle(currentMediaTime);						if (subTitle != null && subTitle != ""){							// Call callback							callback(subTitle);														subTitleSet = true;														_currentIndex = i;							_currentStartTime = textItems[i].getStartTime();							_currentEndTime = textItems[i].getDuration() + _currentStartTime;							break;						}					}														}								// send empty text to callback if subtitle not found				if(!subTitleSet){					callback("");				}							}else if (netStream == null){				stopTimer();				callback("");			}			}				public function stop():void{			stopTimer();			if(callback != null){				callback("");			}		}				public function setEventCallback(eCb:Function):void{			eventCallback = eCb;		}				private function showEvent(e:String):void{			if(eventCallback != null){				eventCallback(e);			}		}			}}